---
title: 铜陵城市超脑前端技术梳理
date: 2019-09-20 21:04:04
tags:
  - Vue
  - 前端技术栈
categories:
  - Vue
  - 前端技术栈
---

# 铜陵城市超脑前端技术栈梳理

> 今天的分享培训，分为三个部分，一个是对于项目中，前端采用的技术栈，进行一个简单的梳理。另外一个，就是如何去运行，如何去构建我们的前端项目，我会对其中的步骤进行讲解。最后，会给项目中的一些代码给出建议。


## 一、技术栈梳理

> 背景 前后端分离，敏捷，并行开发，责任和分工清晰。

> vue全家桶，什么是vue全家桶，从前端项目构建，到开发，到部署上线，使用的都是基于vue生态链中的工具和类库。

> 本项目使用的是vue + vue-cli + vue-router + axios + vuex + ant-design-vue，后面会依次给大家介绍这些东西都能干些什么，或者说，与以前的开发模式相比，都替代了什么

### 1、VUE

> vue是一种用于构建用户界面的mvvm框架，它的核心专注于视图层，实际开发中，便于与第三方库进行功能整合。所谓的mvvm与mvc类似，后面的vm称为视图模型，其实就是mvc中的controller变化而来。为什么使用vue来进行项目的开发呢，它的优点如下：

#### 组件化
> 组件是Vue强大的功能之一，组件可以扩展 HTML 元素，封装可重用的代码。在以前的开发模式中，可能前端页面需要用到多个地方的相似代码，我们都要依次进行复制粘贴和改动。但是组件化以后，我们只需要进行多次的引用就可以。比方说大屏里使用到的swiper组件，头部底部，视频播放组件，图片查看组件等，这些都是组件化的实践，代码分层解耦清晰，不仅利于前期开发，更利于后期的管理和维护。

#### virtual dom
> 体现vue的强大和性能优势的另一特点，就是虚拟dom，一般来说，dom操作比较昂贵，dom对象里包含的属性太多，导致每一次的改动，都是对浏览器性能的较大消耗。这里牵扯到浏览器的重绘和回流概念，这里不做引申。一句话概括，频繁的dom操作，会降低页面的性能，与数据量大小成正比，并且指数增长。

> 因此，虚拟dom这个解决方案就出来了，什么是虚拟dom，实际上就是，使用js对象，模拟dom对象的重要属性和主要结构，dom对象的结构，节点之间的关系，其实就是数据结构里的树.因此就是js对象树，模拟dom对象树。将每一次dom数据的变化，进行有序的队列控制，在下一次的dom更新前，对新旧节点进行对比，生成差异，再进行统一的更新渲染，至于渲染时间的控制，这里牵扯到浏览器的事件触发原理，不做引申。可能这种阐述，比较难以理解，这些不重要，简单一句话概括，Virtual dom提升了页面性能，优化了浏览器的渲染，属于最大程度上的最佳实践。

#### 响应式
> 真正解放我们，不用手动做view和model之间的变化响应的，便是这个响应式系统。

> “响应式”，是指当数据改变后，Vue 会通知到使用该数据的代码。视图渲染中使用了数据，数据改变后，视图也会自动更新。

> 我们可以回想下，在jq时代，我们如何去实现视图与数据之间的交互呢？无非是面向过程的那一套东西，取元素，设置属性值，取元素，获取属性值，等等。而Vue的响应式系统，实际底层也是做dom节点的操作，但是更高效。Vue将这部分操作，封装在内部的实现中，我们只需要简单操作，就能实现视图和数据之间的交互。

> 在每个页面组件中，数据可以是提前定义好的页面既有字段，也可以是后端接口给出的数据对象。

> 响应式背后的原理，其实就是运用了设计模式中的观察者模式，通过对data属性的监视，触发能够更新视图数据的watcher，并且进行dom的渲染。

> 响应式的好处，就是解耦视图和模型，我们不用去关注他们之间具体如何的联动和变化，我们只需要进行数据层面的操控，而由响应式系统，替我们完成视图层面的变化。

### 2、vue-cli

> vue-cli是有Vue提供的一个官方cli，专门为单页面应用快速搭建繁杂的脚手架。它是用于自动生成vue.js+webpack的项目模板

> 它暴露了一个可以自定义webpack配置的接口，我们可以在它的基础上，灵活配置我们项目需要的webpack配置，比如模块引入，样式预处理，热更新，开发模式的代理，等等。

### 3、vue-router
> vue-router实际上就是前端路由控制系统，其原理是通过html5的history API或者hash模式，实现单页应用内部功能模块的页面切换，即不刷新，便能改变地址，并且改变页面展示模块。

> 前端打包输出的文件，其实就只有一个index.html，整个系统都是单页，因此页面之间的切换，包括返回，效率和性能都会很高，其实就是路由系统在控制，根据地址的字段映射，展示对应的页面组件，实际上，都是在一个页面上发生的。

### 4、axios

> axios是一个基于promise的http库，它适用于浏览器和node.js中,在vue全家桶中，作为ajax请求的代替，简单说，就是发送http请求的，它支持请求和响应的拦截，这个特性我们可以进行登录拦截，报错收集等统一的处理，还能够对数据进行统一的改造，使的前端代码逻辑变得清晰简单。

> 一般来说，在我们实际项目的请求中，为了安全性，统一使用的post，而Post请求，后端默认的处理，应该就是表单提交formdata的格式，即content-type就是application/x-www-form-urlencoded，但是axios默认的application/json，因此如果直接传递，不做处理，服务器会报500的错，所以我们正常需要使用qs这个库，来对json形式的数据，进行序列化，也就是类似a=b&b=c的格式，才能正常完成请求交互。

### 5、vuex
> vuex是vue项目的状态管理工具，所谓状态管理，其实就是对于一些全局的数据，状态，进行统一的获取，更改，异步等操作。处于一种可预测的变化中。比如，用户登录状态，更新一处，多处联动信息的变化。方便全局数据的管理。

> 另外我看项目中，使用到了vuex-persistedstate这样的一个插件，其实这个插件是用来对Vuex在内存中的数据，进行持久化的，项目中通过将Vuex中的数据，存入sessionStorage，来进行持久化，防止页面在刷新的时候，数据丢失的问题。sessionStorage的持久化比较折中，其生命周期只存在于这一次打开的浏览器中，关闭浏览器，则会清除。

### 6、ant-design-vue

> ant-design-vue是基于vue开发的一个UI框架。

> 一般来说，中后台的系统，其UI样式和功能交互，几乎趋于统一，所以，这个利于使用UI框架来进行快速的页面构建，很多页面组件，如下拉框，表格，弹窗等，UI框架都提供了简便的引用方式，而且扩展性强。

> 而对于项目中大屏的前端页面，用于前端定制话的东西比较多，很多样式和交互，UI框架并不能提供，因此大多会使用手动编写，而对于常用的功能组件，可以进行选择引入，比如，pagination这个组件，用来进行列表的分页。


## 二、项目启动（开发模式和生产模式）

> 这部分主要给后端介绍下，项目的前端项目如何跑起来，如何构建生产环境的包。

### 1、node.js安装 npm 

> 目前前端项目构建，都是基于Node环境的，所以前提需要安装Node版本，版本是适当的高一点，比较牢靠，[这里](https://nodejs.org/zh-cn/)是Node下载的链接地址。

> npm 是前端项目的包管理工具，是开发和构建所用到的一切工具和类库的管理工具。现在Node安装会自动安装npm，环境变量也会自动配好，因此，我们只需要安装nodejs就可以了。

### 2、初始化项目
> npm 是通过命令行操作的，所有操作，基于命令行。这里初始化，就不介绍，一个项目从无到有的生成，这里涉及vue-cli的相关知识，通常情况下，后端人员拉取前端项目源码的时候，项目已经初始化了。

> 这里我要说的是，项目拉取之后，该怎么操作。首先，项目拉取下来之后，在package.json文件所在的目录下，打开命令行，输入npm install 也就是安装下项目依赖的所有包文件。

> 等安装成功之后，输入npm run serve这是本地开发模式启动的命令，端口默认是8080。

### 3、package.json简单介绍

> package.json其实就是项目中，展示模块以及配置信息的文件，一般我们通过修改它来完成一些自定义的东西，主要介绍三个属性，是与我们开发密切相关的。

> scripts 就是配置项目运行或是打包等操作的属性。

```
"scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint",
    "test:unit": "vue-cli-service test:unit"
  },
```

> dependencies 项目依赖包，也就是，不论是开发模式，还是生产模式，项目中必须依赖的包，都会在这里集成，我们通过npm install XX --save-dev来安装的包，就是集成到这个属性的配置中去的。

```
"dependencies": {
    "ant-design-vue": "^1.3.5",
    "axios": "^0.18.0",
    "echarts": "^4.2.1",
    "jquery": "^2.2.1",
    "mockjs": "^1.0.1-beta3",
    "moment": "^2.24.0",
    "qs": "^6.6.0",
    "v-viewer": "^1.4.0",
    "vue": "^2.5.22",
    "vue-router": "^3.0.1",
    "vuex": "^3.0.1",
    "vuex-persistedstate": "^2.5.4"
  },
```

> devDependencies 顾名思义，这个属性就是开发环境专属的依赖包，比如，我们需要对代码中用到的样式预处理文件，通过对应的预处理器，去进行转化编译，形成生产环境可用的样式文件，那么，这个预处理工具，就适合集成到这个属性中去。

```
"devDependencies": {
    "@babel/polyfill": "^7.2.5",
    "@vue/cli-plugin-babel": "^3.4.0",
    "@vue/cli-plugin-eslint": "^3.4.0",
    "@vue/cli-plugin-unit-mocha": "^3.4.0",
    "@vue/cli-service": "^3.4.0",
    "@vue/eslint-config-standard": "^4.0.0",
    "@vue/test-utils": "^1.0.0-beta.20",
    "babel-eslint": "^10.0.1",
    "chai": "^4.1.2",
    "eslint": "^5.8.0",
    "eslint-plugin-vue": "^5.0.0",
    "less": "^3.0.4",
    "less-loader": "^4.1.0",
    "lint-staged": "^8.1.0",
    "vue-image-swipe": "^1.0.5",
    "vue-template-compiler": "^2.5.21"
  },
```

### 4、开发模式相关配置

> 开发环境的启动 是通过npm run serve来进行的，我们可以在package.json的scripts中的serve配置里，后面加上--open，这样，我们每次启动开发环境成功后，会自动打开浏览器。默认8080端口。

> 另外需要注意的点是，后期在和后端接口进行交互的时候，实际上，直接调用，就属于跨域了，开发环境可以在vue.config.js(如果没有，则自己新建)文件中，进行相关配置：

```
proxy: {
      '/tl-cyberbrain-govern': {
        target: 'http://59.203.208.71:8088',
        changeOrigin: true,
        logLevel: 'debug'
      }
    }
```
> 比如上面代码，是项目中的一个代理配置，/tl-cyberbrain-govern 就是要代理的地址前缀，target就是代理的目标，比方说，我们要想访问http://59.203.208.71:8088/tl-cyberbrain-govern/api，那么做出如上配置之后，我们只需要访问/api，就能够绕过跨域问题，拿到数据了。


### 5、生产模式相关配置

> 我们通过npm run build命令，来对开发好的前端代码，进行编译和打包，代码输出到项目目录的dist文件夹中，之后，由后端进行部署。

> 其中有注意的地方，就是，如果前端项目所处的线上位置，相对于服务器根目录，前面有嵌套路径，那么，这个路径需要给前端，在vue.config.js里的publicPath中配置，否则静态资源会获取不到：

```
publicPath: process.env.NODE_ENV === "production" ? "/path" : "/"
```

> process.env.NODE_ENV是Node中，展示当前环境的变量，如果是生产环境，那么，所有静态资源的引用路径，在打包之后，前面都会加上设置的对应的路径，与线上环境一致。



## 三、项目中的一些建议
> 这部分，我来简单讲下，对于项目中的一些做法和建议

### 接口调用应该和页面代码进行解耦

> 项目中的数据请求，每一个都是直接写在页面中的，按照经验来说，之前我有遇到过这样一种情况，后端接口服务变化，比如地址变了，端口变了，甚至接口字段，请求方式，传参方式都会变动，那如果直接写在页面中，后期维护和更改，会比较麻烦，得一处一处的去修改。

> 建议是，单独将每个模块的接口部分，单独拎出来，用一个api文件夹包括，这样，我们在对应的模块，只需引入对应的api文件。api文件夹里，其实就是各种请求的接口。这样统一，能方便后期接口的管理。

### vuex状态管理应该进行模块解耦

> 目前项目中，使用到vuex状态管理的，不太多，不知道后期项目，会不会越来越庞大，如果越来越庞大了，现在这种，所有模块都糅杂到一个store中的方式，也不太合适，vuex支持按模块的引入，针对后期模块多的情况，可以按模块划分，这样分层更清晰。

> 另外，建议对mutation单独做一层type的映射，降低耦合性，打个比方：

```js
//mutation-types.js
export const SET_USER_INFO = 'setUserInfo'

```

```js
//mutations.js
import * as types from './mutation-types'

export default {
    [types.SET_USER_INFO](state, userInfo) {
        state.userInfo = userInfo;
    },
}

```

> 这样如果setUserInfo这个Mutation需要做变化了的话，我们只需要修改mutation-type就可以了，不用去每个用到该Mutation的地方去依次修改名称。进一步提高可维护性。

### 适度进行一些变量的优化

> 目前项目里在页面中访问vuex store里面的state的时候，是使用this.$store.state.xx来进行获取，而且每个地方用到了，都得重新写一遍，建议后期可以优化一下，避免掉过长的读取链，比如，Vuex框架中提供了一些API来简化我们的数据操作，比如获取state，就用mapState,获取getter，就用mapGetters等等。




